{
    "collab_server" : "",
    "contents" : "require(tools)\nrequire(knitr)\nrequire(rmarkdown)\nrequire(blme)\nrequire(lme4)\nrequire(ggplot2)\nrequire(haven)\nrequire(R2MLwiN)\n\n# require(foreign)\n# require(pander)\n# require(knitr)\n# require(grid)\n# require(scales)\n# require(gridExtra)\n# require(PairedData)\n\n#' Generate individual centre reports - in pdf - for the CCUK analysis using data in a specific format\ngenReport <- function(output.dir = paste(getwd(), \"/Outputs/\", sep = \"\"), Hub = \"South West\", code.hub = \"SWSW\", Overwrite = FALSE){\n  \n  Hub.Name = Hub\n  codedHub.Name = code.hub\n  output.file = paste(\"Report_\", Hub, \".pdf\", sep = \"\")\n  \n  ### render documentation: Generate pdf documenting variables based on defined settings\n  if (output.file %in% list.files(output.dir) & !(Overwrite)){\n    warning(\"There is already a file with the same name in this location.\nThe output file name is modified by adding the current date to the end of the name.\n\\n If you wish to overwrite the existing file, please set the 'Overwrite' to TRUE.\",\n            call. = FALSE, immediate. = TRUE)\n    \n    output.file = paste(tools::file_path_sans_ext(output.file),\n                        \"_\", format(Sys.time(), format = \"%d%m%y\"),\n                        \".pdf\", sep = \"\")\n  }\n  \n  render(paste(getwd(), \"/Rmd/Master.Rmd\", sep = \"\"), \"pdf_document\", output_dir = output.dir, output_file = output.file,\n         quiet = TRUE)\n  cat(\"Finished - Report for \", Hub, \" has been successfully generated ...\\n\", sep = \"\")\n}\n\n#' VPC estimation - using Simulation method\n#' @description The Variance Partition Coefficient of a multilevel model using 'simulation'.\n#' This method is described by the Bristol centre for multilevel modelling. You can find it here:\n#' http://www.bristol.ac.uk/cmm/software/support/support-faqs/pval.html\n#' @param model the fitted model\n#' @param X.values matrix of specific values of x by which you wish to estimate the VPC. Each column represents\n#' a variable. Each row is a value. Note value for x0 (first column) should always be set as 1.\n#' @param m number of simulated variance values.\n#' @example\n#' fit_1 <- glmer(dento ~ age + sex + (1 | hub), family = binomial(\"logit\"), data = CCUK, nAGQ = 100)\n#' X.values = matrix(nrow = 2, byrow = TRUE, data = c(1,0,1,1,0,0))\n#' VPC.est(fit_1, X.values, m=5000)\nVPC.est = function(model, X.values = matrix(nrow = 2, byrow = TRUE, data = c(1,0,1,1,0,0)), m = 5000){\n  # extract sd of random effect (sigma_u)\n  H.sigma = sqrt(as.numeric(summary(model)$varcor))\n  # extract the estimated parameters\n  beta = summary(model)$coefficients[,\"Estimate\"]\n  # Generate 'm' values of level2 residuals from norma(0, (sigma_u))\n  L2.Residual = rnorm(m, 0, H.sigma)\n  \n  # calculate probabilities by adding the XB (i.e., given X.values * beta) to the generated residuals\n  XB = apply(sweep(X.values, MARGIN=2, beta, FUN=`*`), 1, sum)\n  Prob = c()\n  for(i in 1:length(XB)){\n    Prob = c(Prob, XB[i] + L2.Residual)\n  }\n  Prob = exp(Prob) / (1 + exp(Prob))\n  Var = Prob*(1-Prob)\n  V1 = mean(Var)\n  V2 = var(Prob)\n  VPC = V2 / (V1 + V2)\n  return(list(V1 = V1, V2 = V2, VPC = VPC))\n}\n\n#' calculate model statistics\n#' @param ML.model multilevel model\n#' @param single level model\nmodel.Stat = function(ML.model, single.model){\n  VPC = VPC.est(ML.model)\n  Pvalue = 1-pchisq(as.numeric(-2*(logLik(single.model)-logLik(ML.model))) ,1)\n  \n  beta = summary(ML.model)$coefficients[1, \"Estimate\"]\n  H.sigma = sqrt(as.numeric(summary(ML.model)$varcor))\n  PI_1 = Trans(beta, 0)\n  if (H.sigma >= .01){\n    CI.lower_1 = Trans(beta, -1.96*H.sigma)\n    CI.upper_1 = Trans(beta, 1.96*H.sigma)\n  } else {\n    CI.lower_1 = Trans(beta, -1.96*VPC$V2)\n    CI.upper_1 = Trans(beta, 1.96*VPC$V2)\n  }\n  return(list(VPC=VPC, Pvalue=Pvalue, beta=beta, H.sigma=H.sigma, PI_1=PI_1,\n              CI.lower_1=CI.lower_1, CI.upper_1=CI.upper_1))\n}\n\n#' Transform model parameter estimates from logit scale to proportions\n#' @param Beta parameter estimate\n#' U a value that can be added to beta (zero: to transform beta; 1.96*sd to transform upper limit of C.I)\nTrans <- function(Beta, U){\n  odds = exp(Beta+U)\n  Pi = odds/(1+odds)\n  return(Pi)\n}\n\n#' calculate model statistics\n#' @param ML.model multilevel model\n#' @param single.model single level model\n#' @param DF dataframe that contain variables to use for plot\n#' @param Response The name of the considered response variable\n#' @param Plot logical if true, a plot will be generated.\nUni.Stat = function(ML.model, single.model, DF, Response, Plot=TRUE,\n                    codedHub.Name, Hub.Name){\n  VPC = VPC.est(ML.model)\n  Pvalue = 1-pchisq(as.numeric(-2*(logLik(single.model)-logLik(ML.model))) ,1)\n  \n  beta = summary(ML.model)$coefficients[1, \"Estimate\"]\n  H.sigma = sqrt(as.numeric(summary(ML.model)$varcor))\n  PI_1 = Trans(beta, 0)\n  if (H.sigma >= .01){\n    CI.lower_1 = Trans(beta, -1.96*H.sigma)\n    CI.upper_1 = Trans(beta, 1.96*H.sigma)\n  } else {\n    CI.lower_1 = Trans(beta, -1.96*VPC$V2)\n    CI.upper_1 = Trans(beta, 1.96*VPC$V2)\n  }\n  U0    <- ranef(ML.model, condVar = TRUE)\n  U0se  <- sqrt(attr(U0[[1]], \"postVar\")[1, , ])\n  U0tab <- cbind(U0[[1]], U0se)\n  colnames(U0tab)[1] <- \"U0\"\n  U0tab <- cbind(U0tab, Trans(beta, U0tab$U0))\n  colnames(U0tab)[3] <- \"PIj\"\n  U0tab <- U0tab[order(U0tab$PIj),]\n  U0tab <- cbind(U0tab, c(1:dim(U0tab)[1]))\n  colnames(U0tab)[4] <- c(\"U0_rank\")\n  #### Use This to report individual differences from mean\n  U0tab_1 <- cbind(PIj = U0tab$PIj, lower = Trans(beta, U0tab$U0-1.96*U0tab$U0se), upper = Trans(beta, U0tab$U0+1.96*U0tab$U0se)) -  PI_1\n  row.names(U0tab_1) <- row.names(U0tab)\n  Hub.Size <- as.matrix(table(DF[['unit']][!(is.na(DF[[Response]]))]))\n  U0tab_1 <- cbind(Size = Hub.Size[match(rownames(U0tab_1), rownames(Hub.Size))], U0tab_1)\n  \n  if(Plot){\n    ## plot\n    cutoff <- data.frame(x = c(-Inf, Inf), y = c(PI_1,PI_1))\n    Ident <- which(rownames(U0tab_1) == codedHub.Name)\n    \n    P <- ggplot(U0tab, aes(U0_rank, PIj)) + geom_point(size=3, shape=18) +\n      scale_x_continuous(breaks=Ident, labels=Hub.Name) +\n      geom_segment(aes(x=U0tab$U0_rank, y=Trans(beta, U0tab$U0-1.96*U0tab$U0se), xend=U0tab$U0_rank, yend=Trans(beta, U0tab$U0+1.96*U0tab$U0se)),\n                   size=0.6, arrow=arrow(angle=90, ends=\"both\", length = unit(0.08, \"inches\"))) +\n      geom_line(aes(x,y), cutoff, size=0.5, linetype=\"dashed\") + scale_y_continuous(limits = c(0, 1)) + labs(x = \"Centre\", y = \"Proportion\")\n    \n    P <- P + theme(axis.text=element_text(size=14, face=\"bold\"),\n                   axis.text.x=element_text(angle=20, vjust=0.5, hjust = 0.5),\n                   axis.text.y=element_text(vjust=0.5, hjust = 0.5),\n                   plot.margin = unit(c(0.3,0.9,0.3,0.3), \"cm\"),\n                   axis.title=element_text(size = rel(1.8)),\n                   axis.title.x=element_text(vjust=-0.5),\n                   axis.title.y=element_text(vjust=1.5),\n                   panel.background = element_rect(fill = 'white', colour = 'black'),\n                   panel.grid.major = element_line(colour = 'grey89'), panel.grid.minor = element_line(colour = 'grey89'))\n    return(list(Stat = list(VPC=VPC, Pvalue=Pvalue, beta=beta, U0tab=U0tab_1, PI_1=PI_1, CI.lower_1=CI.lower_1, CI.upper_1=CI.upper_1), Plot=P))\n  } else {\n    return(list(VPC=VPC, Pvalue=Pvalue, beta=beta, U0tab=U0tab_1, PI_1=PI_1, CI.lower_1=CI.lower_1, CI.upper_1=CI.upper_1))\n  }\n}\n\n#' Table's caption for latex format\n#' @description return a latex format to include table caption\n#' @param caption string of your caption\ntabCap <- function(caption){\n  paste0(\"\\\\textit{\", caption, \"}\")\n}\n\n#' deterministic decimal places\n#' @description specify how many decimal numbers do you want to return\n#' @param x the given numer (or a vector of given numbers)\n#' @param k number of decimal places required\nSpecify.dec <- function(x, k = 2){\n  format(round(x, k), nsmall=k)\n}\n\n#' Show plus sign for positive numbers\n#' @description return a text showing the plus '+' sign in front of positive numbers.\nSign.dif <- function(Number){\n  if(as.numeric(Number) > 0){\n    paste0(\"+\",Number)\n  } else\n    Number\n}\n\n#' Pre-processing data imported by the 'haven' package\n#' @description This function is used to present factors by labels, replace NaN by NA (in order to have all missing values coded in the same way)\n#' @param df data frame imported from Stata data file by the rio package\n#' @export\nPost.Haven <- function(df){\n  DF = as.data.frame(df)\n  DF[is.na(DF)] <- NA\n  f = function(x){\n    if(haven::is.labelled(x)){Out = haven::as_factor(x)} else {Out = x}\n  }\n  for(i in 1:dim(DF)[2]){\n    DF[,i] <- f(DF[,i])\n  }\n  return(DF)\n}\n\n#' Categorize SDQ measures\n#' @param x variable (an SDQ measure) to be categorize\n#' @param cut.breaks The cut points for splitting categories\n#' @param levels labels of the generated levels\nCateg <- function(x, cut.breaks, levels = c(\"Avg.\", \"S.raised\", \"high\", \"V.high\")){\n  factor(cut(x, breaks=cut.breaks), labels = levels)\n}\n\n#' Extract DIC info from MLwiN Outout\n#' @description return a data frame containing information of the DIC of the model fitted using R2MLwiN package\n#' @param MLwiN.model The model outcome obtained by the 'R2MLwiN' package (e.g. using \\code{sink})\nget.DIC <- function(MLwiN.model){\n  sink(\"MLwiN_Out.txt\")\n  print(summary(MLwiN.model))\n  sink()\n  MLwiN.Outputs <- readLines(\"MLwiN_Out.txt\")\n  unlink(\"MLwiN_Out.txt\")\n  LnId <- which(!is.na(stringr::str_match(MLwiN.Outputs, \"Bayesian Deviance Information Criterion \\\\(DIC\\\\)\")))\n  List <- strsplit(MLwiN.Outputs[c(LnId+1, LnId+2)], \"\\\\s+\")\n  Re <- as.numeric(List[[2]]); names(Re) <- List[[1]]\n  Re\n}\n\n#' Extract fixed effect estimates from MLwiN Outout\n#' @description return a data frame containing fixed effect estimates of the model fitted using R2MLwiN package - MIGHT NEED REVISE AS IT MIGHT GET WARNING MESSAGE IF THE CELL (***) IS EMPTY!!!\n#' @param MLwiN.model The model outcome obtained by the 'R2MLwiN' package\nGet.Fixed.est <- function(MLwiN.model){\n  sink(\"MLwiN_Out.txt\")\n  print(summary(MLwiN.model))\n  sink()\n  MLwiN.Outputs <- readLines(\"MLwiN_Out.txt\")\n  unlink(\"MLwiN_Out.txt\")\n  LnId.start <- which(!is.na(stringr::str_match(MLwiN.Outputs, \"The fixed part estimates:\")))\n  LnId.end <- which(!is.na(stringr::str_match(MLwiN.Outputs, \"Signif. codes:\\\\s*\\\\.*\")))\n  # split items by spaces\n  List <- strsplit(MLwiN.Outputs[(LnId.start+2):(LnId.end-1)], \"\\\\s+\")\n  Raw.Re <- data.frame(do.call(\"rbind\", List))\n  names(Raw.Re) <- c(\"\", \"Coef.\", \"Std. Err.\", \"z\", \"Pr(>|z|)\", \"\", \"95% CI.lower\", \"95% CI.upper\", \"ESS\")\n  Raw.Re[,-c(1,6)] <- apply(Raw.Re[,-c(1,6)], 2, function(x){as.numeric(as.character(x))})\n  Re <- Raw.Re\n  return(Re)\n}\n\n#' Extract random part estimates from MLwiN Outout\n#' @description return a vector containing random effect estimates of the model fitted using R2MLwiN package\n#' @param MLwiN.model The model outcome obtained by the 'R2MLwiN' package\nGet.Random.est <- function(MLwiN.model){\n  sink(\"MLwiN_Out.txt\")\n  print(summary(MLwiN.model))\n  sink()\n  MLwiN.Outputs <- readLines(\"MLwiN_Out.txt\")\n  unlink(\"MLwiN_Out.txt\")\n  LnId <- which(!is.na(stringr::str_match(MLwiN.Outputs, \"^var_\\\\w+\")))\n  List <- strsplit(MLwiN.Outputs[LnId], \"\\\\s+\")\n  Raw.Re <- data.frame(do.call(\"rbind\", List))\n  names(Raw.Re) <- c(\"\", \" Coef.\", \"Std. Err.\", \"95% CI.lower\", \"95% CI.upper\", \"ESS\")\n  Raw.Re[,-1] <- apply(Raw.Re[,-1], 2, function(x){as.numeric(as.character(x))})\n  Re <- Raw.Re\n  return(Re)\n}\n\n#' Collect statistics for summary table\n#' @description Organise all required information for summary table and return them all in a list\n#' \nSet.Sumary = function(Model, P, CI.l, CI.u, VPC, Pval, tab.ind){\n  n = summary(Model)$devcomp$dims[\"n\"]\n  return(list(n=n, P=P, CI.l=CI.l, CI.u=CI.u, VPC=VPC, Pval=Pval, tab=tab.ind))\n}\n\nSDQ.Sumary = function(N, P, CI, VPC, Pval, Size, tab.ind, Cat = \"Avg.\", codedHub.Name){\n  n = sum(N)\n  P = P[Cat]\n  CI.l = CI[Cat, \"lower\"]\n  CI.u = CI[Cat, \"upper\"]\n  Size = Size[Cat, codedHub.Name]\n  P.ind = tab.ind[Cat,1,codedHub.Name] - P\n  l.ind = tab.ind[Cat,2,codedHub.Name] - P\n  u.ind = tab.ind[Cat,3,codedHub.Name] - P\n  return(list(n=n, P=P, CI.l=CI.l, CI.u=CI.u, VPC=VPC, Pval=Pval, Size=Size, P.ind=P.ind, l.ind=l.ind, u.ind=u.ind))\n}",
    "created" : 1495183301916.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4170137497",
    "id" : "3DEACF45",
    "lastKnownWriteTime" : 1498558509,
    "last_content_update" : 1498558509,
    "path" : "~/O-Drive/Github/CCUK-GenRep/R/Rfuns.R",
    "project_path" : "R/Rfuns.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}